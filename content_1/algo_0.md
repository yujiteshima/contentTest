# EDPC全部やる

## DPを解く方針
以下の三つを考える
- 埋める配列
- 計算方法
- 埋める順番

## Frog1
解き方の典型考察
> カエルが足場Nに辿り着くまでに支払うコストの総和の最小値を求めて下さい。

というようにくればまず、Nを動かすことを考える。
このNが添字に来るようなDP配列を考える。

- 埋める配列
  dp[x] = 足場0からスタートして足場xに着地する時に足場xまでに払うコストの最小値
- 計算方法
  dp[0] = 0
  dp[x] = min(
    dp[x-1] + |h[x-1]-h[x]|,
    dp[x-2] + |h[x-2]-h[x]|
  )
  dp[x-1] + |h[x-1]-h[x]|: 一つ前から飛んでくるパターン、一つ前までのコスト(dp[x-1]) と
  一つ前か飛んでくる際のコスト(|h[x-1]-h[x]|) ここでは一つ前の足場の高さと、現在の足場の高さの差
  dp[x-2] + |h[x-2]-h[x]|: 二つ前から飛んでくるパターン、二つ前までのコスト(dp[x-2]) と
  二つ前から飛んでくる際のコスト(|h[x-2]-h[x]|) ここでは、二つ前の足場の高さと、現在の足場の高さの差
　
    ここで本当にこの計算方法で良いのかを疑ってかからなければならない。
    dp[x]を求めるためにdp[x-1]を使って良いか？
    ex) x-1までの行き方は最小値じゃない飛び方をしたが,そういうふうな飛び方をしなければxには最小値でなければ
    辿り着かないという状況があるかどうかを考えなければならないが、抽象的にminとプラスの条件式であるから等厳密に
    考えなくても、最小値に値を足せば新しい最長値だと直感的に分かれば良い。

- 埋める順番
  xが小さい順

足場の初期値を0にしている。
元の問題の足場は1から始まっているが1から始まっているのは人間のエゴ
コンピュータは0からなので0Indexで初期化していく。

dp[0]の時のコストは、0からスタートして0に着地する際のコスト。これを0とする。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<string>
#include<queue>
#include<stack>
using namespace std;
#define MOD 1000000007
#define MOD2 998244353
#define INF((1<<30)-1)
#define LINF (1LL<<60)
#define EPS (1e-10)
typedef long long Int;
typedef pair<Int, Int> P;

Int dp[110000];
Int n, h[110000]
int main () {
    // 入力
    cin >> n;
    for(int i = 0; i < n; i++) cin >> h[i];
    
    dp[0] = 0;
    
    return 0;
}
```
1. dp配列を格納する変数を用意する。この時にNの制約を確認してそれより大きい大きさの配列が入る変数を用意する。
2. 