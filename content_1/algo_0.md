# EDPC全部やる

## DPを解く方針
以下の三つを考える
- 埋める配列
- 計算方法
- 埋める順番

## Frog1
解き方の典型考察
> カエルが足場Nに辿り着くまでに支払うコストの総和の最小値を求めて下さい。

というようにくればまず、Nを動かすことを考える。
このNが添字に来るようなDP配列を考える。

- 埋める配列
  dp[x] = 足場0からスタートして足場xに着地する時に足場xまでに払うコストの最小値
- 計算方法
  dp[0] = 0
  dp[x] = min(
    dp[x-1] + |h[x-1]-h[x]|,
    dp[x-2] + |h[x-2]-h[x]|
  )
  dp[x-1] + |h[x-1]-h[x]|: 一つ前から飛んでくるパターン、一つ前までのコスト(dp[x-1]) と
  一つ前か飛んでくる際のコスト(|h[x-1]-h[x]|) ここでは一つ前の足場の高さと、現在の足場の高さの差
  dp[x-2] + |h[x-2]-h[x]|: 二つ前から飛んでくるパターン、二つ前までのコスト(dp[x-2]) と
  二つ前から飛んでくる際のコスト(|h[x-2]-h[x]|) ここでは、二つ前の足場の高さと、現在の足場の高さの差
　
    ここで本当にこの計算方法で良いのかを疑ってかからなければならない。
    dp[x]を求めるためにdp[x-1]を使って良いか？
    ex) x-1までの行き方は最小値じゃない飛び方をしたが,そういうふうな飛び方をしなければxには最小値でなければ
    辿り着かないという状況があるかどうかを考えなければならないが、抽象的にminとプラスの条件式であるから等厳密に
    考えなくても、最小値に値を足せば新しい最長値だと直感的に分かれば良い。

- 埋める順番
  xが小さい順

足場の初期値を0にしている。
元の問題の足場は1から始まっているが1から始まっているのは人間のエゴ
コンピュータは0からなので0Indexで初期化していく。

dp[0]の時のコストは、0からスタートして0に着地する際のコスト。これを0とする。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cassert>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<string>
#include<queue>
#include<stack>
using namespace std;
#define MOD 1000000007
#define MOD2 998244353
#define INF((1<<30)-1)
#define LINF (1LL<<60)
#define EPS (1e-10)
typedef long long Int;
typedef pair<Int, Int> P;

Int dp[110000];
Int n, h[110000]
int main () {
    // 入力
    cin >> n;
    for(int i = 0; i < n; i++) cin >> h[i];
    
    dp[0] = 0;
    
    return 0;
}
```
1. dp配列を格納する変数を用意する。この時にNの制約を確認してそれより大きい大きさの配列が入る変数を用意する。

## Frog2

- 埋める配列
    dp[x] = 足場0からスタートして足場xに着地する時に足場xまでに払うコストの最小値
- 計算方法
    dp[0] = 0;

    min1をとる回数が2回であれば2個書けばいいが、k個ではそのようにできない。
    for文で書かなくてはならない。そのような時は一個ずつ見ていけば良い。
    今回の場合は今までの最小値と比べて小さければ更新する。
    i=1の時にkが3でi-3とかの配列を見るとセグフォとなる。
    ```cpp
    if(i-j>=0)
      dp[i] = min(dp[i], dp[i-j] + abs(h[i] - h[i-j]));

## Vacation
- 埋める配列
  dp[x][i] = x日目にiに行く時のx日目までの幸福度の総和の最大値
  i: 海, 山, 宿題, 0,1,2
  前日に何をしたかで取れる選択が変わるため、前日何をしたかという情報をテーブルに
  含める必要がある。
  dp[0][i] = 適切な幸福度
  dp[x][i] = min(dp[x-1][j] + 増える幸福度)
    j != i に関するminをとる
- 計算方法
  dp[0]から始まっているのでdp[-1]に番兵を置きたいが-1という添字は作れないので、
  dp[0]=0として、1indexとして考える。
  dp[x][i] = min(dp[x-1][j] + 増える幸福度)
    j != i に関するminをとる
- 埋める順番
    xが小さい順,iは好きな順

Tips：dp[0]の初期化がめんどくさくなったら、番兵を用意するとスッキリするかも。

```cpp
Int n;
Int happy[110000][3];
Int dp[110000][3]
// 0:umi 1:yama 2:HW
int main () {
    cin >> n;
    for(int i = 0; i <= n; ++i){
        cin >> a[i] >> b[i] >> c[i]
    }
    for(int i = 1;i <= n;i++){
        for(int place = 0; place < 3; place++){
            for(int placeY = 0; placeY < 3; placeY++){
                if(place == placeY) continue;
                dp[i][place] = max(dp[i][place],
                dp[i-1][placeY] + happy[i][place]);
            }
        }
    }
    Int ans = 0;
    for(int place = 0; place < 3; place++){
        ans = max(ans, dp[n][place])
    }
    cout << and << endl;
    return 0;
}
```

- dpテーブルには数字以外が入る場合もある。
- 番兵使うといいよ。

## Knapsack1

N個の品物, 1...,Nがあり、iの重さはwiで価値がvi, N個の品物のうちいくつかを選び、
ナップサックに入れる。持ち帰る品物の重さの総和はW以下でなくてはならない。
持ち帰る品物の価値の総和の最大値を求めよ。

選び方は2のN乗ある：iを選ぶか選ばないか**n
- 1 <= N <= 100
2 ** 100 => 約10 ** 30

- 埋める配列
    dp[i][w] = i番目までのお菓子で重さがw以下となる選び方の価値の最大値

- 計算方法
    dp[0][j] = 0;// 番兵つまり1index
    dp[i][j] = max(dp[i-1][j],
                   dp[i-1][j-w[i]+v[i]])
    - i番目までで重さの総和がj以下を実現するような方法を2通りに分ける。
    - どのように分けるかというと排反に分ける
      - 排反とは：重複もなく漏れもないように分けるということ
    - i番目のお菓子を使ったか使っていないかで分ける。
      dp[i-1][j]: i番目のお菓子を使った
      dp[i-1][j-w[i]+v[i]]: i番目のお菓子を使っていない
- 埋める順番
    iが小さい順、jは好きな順

計算量
n: 100
w: 10^5
dp[i][w] = 10^7
dpテーブルの大きさがdp[N][W]
各DPテーブルの１要素はO(1)で求まるので計算量はO(NW):10^7



